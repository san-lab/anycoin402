<!DOCTYPE html>
<html>
<head>
  <title>X402 Demo Store</title>
  <style>
    body {
      font-family: sans-serif;
    }
    ul {
      list-style: none;
      padding: 0;
    }
    li {
      margin: 8px 0;
    }
    a {
      color: blue;
      text-decoration: underline;
      cursor: pointer;
    }
    #errorModal {
      display: none;
      position: fixed;
      z-index: 1000;
      left: 0;
      top: 0;
      width: 100%;
      height: 100%;
      background-color: rgba(0,0,0,0.5);
    }
    #modalContent {
      background-color: white;
      margin: 10% auto;
      padding: 20px;
      width: 50%;
      border-radius: 10px;
      box-shadow: 0 0 10px rgba(0,0,0,0.3);
      text-align: center;
    }
    button {
      margin: 8px;
      padding: 8px 16px;
    }
  </style>
</head>
<body>

  <h1>Welcome to the X402 Demo Store</h1>
  <p>Select a resource to access:</p>

  <ul>
    <li><a href="resources?RESID=1" class="resource-link">The King</a></li>
    <li><a href="resources?RESID=2" class="resource-link">The Princess</a></li>
    <li><a href="resources?RESID=3" class="resource-link">The Jester</a></li>
  </ul>

  <button id="connectButton">Connect to MetaMask</button>
  <p id="walletAddress" style="margin-top: 8px;"></p>

  <div id="errorModal">
    <div id="modalContent">
      <p id="errorMessage"></p>
      <select id="paymentOptions" style="width: 100%; margin: 8px 0;"></select>
      <button onclick="signAuthorization()">Sign Payment Authorization</button>
      <button onclick="closeModal()">Close</button>
    </div>
  </div>

  <script>
     const chainIdMap = {
        {{- range $key, $value := .ChainIDs }}
        "{{$key}}": {{$value}},
        {{- end }}
    };

    async function signAuthorization() {

      // Check current network
  const currentChainIdHex = await ethereum.request({ method: 'eth_chainId' });
  const currentChainId = parseInt(currentChainIdHex, 16);

  const selectedIndex = document.getElementById('paymentOptions').value;
  const schema = currentSchemas[selectedIndex];
  
  const expectedChainId = chainIdMap[schema.network];
  console.log("chainids:", currentChainId, expectedChainId);

  if (currentChainId !== expectedChainId) {
    alert(`Please switch your wallet network to ${schema.network} (chainId ${expectedChainId}) before signing.`);
    return; // stop here
  }

  const now = Math.floor(Date.now() / 1000);
  const validAfter = 0;
  const validBefore = now + 86400;
  const nonce = '0x' + [...crypto.getRandomValues(new Uint8Array(32))].map(x => x.toString(16).padStart(2, '0')).join('');

  const from = ethereum.selectedAddress;
  const to = schema.payTo;
  const value = schema.maxAmountRequired;
  const chainId = chainIdMap[schema.network];
  const tokenAddress = schema.asset;
  const tokenName = schema.extra.name;
  const tokenVersion = schema.extra?.version || "2";

  const message = { from, to, value, validAfter, validBefore, nonce };

  const signature = await signTransferAuthorization(message, tokenAddress, tokenName, tokenVersion, chainId);

  const payload = {
    x402Version: 1,
    paymentPayload: {
      x402Version: 1,
      scheme: schema.scheme,
      network: schema.network,
      payload: {
        signature,
        authorization: {
          from,
          to,
          value: value.toString(),
          validAfter: validAfter.toString(),
          validBefore: validBefore.toString(),
          nonce
        }
      }
    },
    paymentRequirements: schema
  };

  console.log("payload:", payload);

  try {
    const response = await fetch(currentHref, {
      method: 'GET',
      headers: {
        'X-Payment': JSON.stringify(payload.paymentPayload)
      }
    });

    if (response.ok) {
      const html = await response.text();
      document.open();
      document.write(html);
      document.close();
    } else {
      const errorData = await response.json();
      const errorMessage = `${errorData.error}\n\n${errorData.details}`;
      alert(`Access denied:\n\n${errorMessage}`);
    }

  } catch (error) {
    console.error("Error fetching resource with payment:", error);
  }

  closeModal();
}

    function closeModal() {
      document.getElementById('errorModal').style.display = 'none';
    }

    let currentSchemas = [];
    let currentHref = null;


    document.querySelectorAll('.resource-link').forEach(link => {
      link.addEventListener('click', async (event) => {
        event.preventDefault();
        const href = link.href;

        try {
          const res = await fetch(href);
          
          if (!res.ok && res.status === 402) {
            const data = await res.json();
            const accepts = data.accepts;

            const select = document.getElementById('paymentOptions');
            select.innerHTML = ''; // Clear existing options

            accepts.forEach((schema, index) => {
              const token = schema.extra?.name || 'Token';
              const amount = schema.maxAmountRequired;
              const network = schema.network;
              const option = document.createElement('option');
              option.value = index;
              option.text = `Pay ${amount / 1e6} ${token} on ${network}`;
              select.appendChild(option);
            });

            currentSchemas = accepts; // store all schemas
            currentHref = link.href;  // store href for later use

            document.getElementById('errorMessage').innerText = `Choose a payment method:`;
            document.getElementById('errorModal').style.display = 'block';
                  
          } else {
            window.location = href;
          }
        } catch (err) {
          console.error("Request failed:", err);
        }
      });
    });

    document.getElementById('connectButton').addEventListener('click', async () => {
      if (typeof window.ethereum !== 'undefined') {
        try {
          const accounts = await ethereum.request({ method: 'eth_requestAccounts' });
          const account = accounts[0];
          document.getElementById('walletAddress').innerText = `Connected: ${account}`;
        } catch (error) {
          console.error("User rejected the connection:", error);
        }
      } else {
        alert("MetaMask is not installed.");
      }
    });

    //----------------
  async function signTransferAuthorization(authorization, tokenAddress, tokenName = "USDC", tokenVersion = "2", chainId) {
  const { from, to, value, validAfter, validBefore, nonce } = authorization;

  console.log("Signature request", authorization, tokenAddress, tokenName, tokenVersion, chainId);

  const domain = {
    name: tokenName,
    version: tokenVersion,
    chainId,
    verifyingContract: tokenAddress
  };

  const types = {
    TransferWithAuthorization: [
      { name: 'from', type: 'address' },
      { name: 'to', type: 'address' },
      { name: 'value', type: 'uint256' },
      { name: 'validAfter', type: 'uint256' },
      { name: 'validBefore', type: 'uint256' },
      { name: 'nonce', type: 'bytes32' }
    ]
  };

  const message = {
    from,
    to,
    value,
    validAfter,
    validBefore,
    nonce
  };

  const typesJson = JSON.stringify({
    types: {
      EIP712Domain: [
        { name: "name", type: "string" },
        { name: "version", type: "string" },
        { name: "chainId", type: "uint256" },
        { name: "verifyingContract", type: "address" }
      ],
      ...types
    },
    domain,
    primaryType: "TransferWithAuthorization",
    message
  });

  const signature = await ethereum.request({
    method: 'eth_signTypedData_v4',
    params: [from, typesJson]
  });

  return signature;
}

async function checkWalletConnection() {
  if (typeof window.ethereum !== 'undefined') {
    try {
      const accounts = await ethereum.request({ method: 'eth_accounts' });
      if (accounts.length > 0) {
        const account = accounts[0];
        document.getElementById('walletAddress').innerText = `Connected: ${account}`;
        return true;
      } else {
        document.getElementById('walletAddress').innerText = 'Wallet not connected';
        return false;
      }
    } catch (error) {
      console.error("Error checking wallet accounts:", error);
      return false;
    }
  } else {
    document.getElementById('walletAddress').innerText = "MetaMask not installed";
    return false;
  }
}

// Call this on page load
window.addEventListener('load', () => {
  checkWalletConnection();
});


  </script>
</body>
</html>
