<!DOCTYPE html>
<html>
<head>
  <title>X402 Demo Store</title>
  <style>
    body {
      font-family: sans-serif;
    }
    ul {
      list-style: none;
      padding: 0;
    }
    li {
      margin: 8px 0;
    }
    a {
      color: blue;
      text-decoration: underline;
      cursor: pointer;
    }
    #errorModal {
      display: none;
      position: fixed;
      z-index: 1000;
      left: 0;
      top: 0;
      width: 100%;
      height: 100%;
      background-color: rgba(0,0,0,0.5);
    }
    #modalContent {
      background-color: white;
      margin: 10% auto;
      padding: 20px;
      width: 50%;
      border-radius: 10px;
      box-shadow: 0 0 10px rgba(0,0,0,0.3);
      text-align: center;
    }
    button {
      margin: 8px;
      padding: 8px 16px;
    }
  </style>
</head>
<body>

  <h1>Welcome to the X402 Demo Store</h1>
  <p>Select a resource to access:</p>

  <ul>
    <li><a href="resources?RESID=1" class="resource-link">The King</a></li>
    <li><a href="resources?RESID=2" class="resource-link">The Princess</a></li>
    <li><a href="resources?RESID=3" class="resource-link">The Jester</a></li>
  </ul>

  <button id="connectButton">Connect to MetaMask</button>
  <p id="walletAddress" style="margin-top: 8px;"></p>
  <label>
  <input type="checkbox" id="encodeCheckbox" checked>
  Encode header
</label>

  <div id="errorModal">
    <div id="modalContent">
      <p id="errorMessage"></p>
      <select id="paymentOptions" style="width: 100%; margin: 8px 0;"></select>
      <button onclick="signAuthorization()">Sign Payment Authorization</button>
      <button onclick="closeModal()">Close</button>
    </div>
  </div>

  <script>
     const chainIdMap = {
        {{- range $key, $value := .ChainIDs }}
        "{{$key}}": {{$value}},
        {{- end }}
    };

    /*
    async function signAuthorization() {

      // Check current network
  const currentChainIdHex = await ethereum.request({ method: 'eth_chainId' });
  const currentChainId = parseInt(currentChainIdHex, 16);

  const selectedIndex = document.getElementById('paymentOptions').value;
  const schema = currentSchemas[selectedIndex];
  
  const expectedChainId = chainIdMap[schema.network];
  console.log("chainids:", currentChainId, expectedChainId);

  const currentNetworkName = Object.keys(chainIdMap).find(key => chainIdMap[key] === currentChainId) || 'Unknown';

  if (currentChainId !== expectedChainId) {
    alert(`Please switch your wallet network to ${schema.network} (chainId ${expectedChainId}) before signing.\n\n` +
    `Your current network is ${currentNetworkName} (${currentChainId}).`);
    return
  }

  const now = Math.floor(Date.now() / 1000);
  const validAfter = 0;
  const validBefore = now + 86400;
  const nonce = '0x' + [...crypto.getRandomValues(new Uint8Array(32))].map(x => x.toString(16).padStart(2, '0')).join('');

  const from = ethereum.selectedAddress;
  const to = schema.payTo;
  const value = schema.maxAmountRequired;
  const chainId = chainIdMap[schema.network];
  const tokenAddress = schema.asset;
  const tokenName = schema.extra.name;
  const tokenVersion = schema.extra?.version || "2";

  var xPaymentHeader;
 if (schema.scheme.startsWith("permit")) {
  const nonce = await fetchPermitNonce(schema.network, schema.asset, from);
  const deadline = validBefore;

  const domain = {
    name: tokenName,                // e.g. "USDC"
    version: tokenVersion,         // e.g. "2"
    chainId: expectedChainId,      // e.g. 84532
    verifyingContract: tokenAddress
  };

  const message = {
    owner: from,
    spender: schema.extra.facilitator,
    value: Number(value),
    deadline
  };

  const signature = await signPermitAuthorization({
    owner: from,
    spender: schema.extra.facilitator,
    value,
    nonce,
    deadline
  }, tokenAddress, tokenName, tokenVersion, expectedChainId);

  xPaymentHeader = buildPermitXPaymentHeader({
    schema,
    domain,
    message,
    nonce,
    signature
  });

  console.log("X-Payment Header (Permit):", JSON.stringify(xPaymentHeader));

} else if (schema.scheme.startsWith("exact") || schema.scheme.startsWith("payer0")) {
  const message = { from, to, value, validAfter, validBefore, nonce };
  const signature = await signTransferAuthorization(message, tokenAddress, tokenName, tokenVersion, chainId);

  const basePayload = {
    signature,
    authorization: {
      from,
      to,
      value: value.toString(),
      validAfter: validAfter.toString(),
      validBefore: validBefore.toString(),
      nonce
    }
  };

  if (schema.scheme.startsWith("payer0")) {
    const dstEid = parseInt(schema.extra?.dstEid);
    if (isNaN(dstEid)) {
      alert("Missing or invalid destEid for payer0 scheme.");
      return;
    }
    console.log(dstEid);

    xPaymentHeader = {
      x402Version: 1,
      scheme: schema.scheme,
      network: schema.network,
      payload: {
        ...basePayload,
        dstEid,
        minAmount: Number(value)
      }
    };
  } else {
    xPaymentHeader = {
      x402Version: 1,
      scheme: schema.scheme,
      network: schema.network,
      payload: basePayload
    };
  }

} else {
  console.log("Unknown scheme:", schema.scheme);
}

  try {
    const encodeHeader = document.getElementById('encodeCheckbox').checked;
const headerValue = encodeHeader
  ? btoa(JSON.stringify(xPaymentHeader))
  : JSON.stringify(xPaymentHeader);

const response = await fetch(currentHref, {
  method: 'GET',
  headers: {
    'X-Payment': headerValue
  }
});


    if (response.ok) {
      const html = await response.text();
      document.open();
      document.write(html);
      document.close();
    } else {
      const errorData = await response.json();
      const errorMessage = `${errorData.error}\n\n${errorData.details}`;
      alert(`Access denied:\n\n${errorMessage}`);
    }

  } catch (error) {
    console.error("Error fetching resource with payment:", error);
  }

  closeModal();
}
*/
    
    async function signAuthorization() {
  // Check current network
  const currentChainIdHex = await ethereum.request({ method: 'eth_chainId' });
  const currentChainId = parseInt(currentChainIdHex, 16);

  const selectedIndex = document.getElementById('paymentOptions').value;
  const scheme = currentSchemes[selectedIndex];

  const expectedChainId = chainIdMap[scheme.network];
  console.log("chainids:", currentChainId, expectedChainId);

  const currentNetworkName = Object.keys(chainIdMap).find(key => chainIdMap[key] === currentChainId) || 'Unknown';

  if (currentChainId !== expectedChainId) {
    alert(`Please switch your wallet network to ${scheme.network} (chainId ${expectedChainId}) before signing.\n\n` +
      `Your current network is ${currentNetworkName} (${currentChainId}).`);
    return
  }

  const now = Math.floor(Date.now() / 1000);
  const validAfter = 0; // Or a more dynamic value if needed
  const validBefore = now + 86400; // 24 hours from now
  const nonce = '0x' + [...crypto.getRandomValues(new Uint8Array(32))].map(x => x.toString(16).padStart(2, '0')).join('');

  const from = ethereum.selectedAddress;
  const to = scheme.payTo;
  const maxAmount = scheme.maxAmountRequired; // This is the 'amount' on the source chain

  const tokenAddress = scheme.asset;
  // Assuming tokenName and tokenVersion might come from schema.extra for consistency
  const tokenName = scheme.extra?.name || "Missing token name";
  const tokenVersion = scheme.extra?.version || "Missing token version";

  const x402Data = {
    scheme,
    network: currentNetworkName,
    chainId: expectedChainId,
    from,
    to,
    maxAmount,
    validAfter,
    validBefore,
    tokenAddress,
    tokenName,
    tokenVersion,
    nonce32: nonce,
    extra: scheme.extra
  };
  console.log(x402Data);
  var xPaymentHeader;

  if (scheme.scheme.startsWith("permit")) {
    xPaymentHeader = await PreparePermitHeader(x402Data);

  } else if (scheme.scheme.startsWith("payer0Plus_")) {
    // === NEW BRANCH FOR payer0Plus_ schemes ===

    // ASSUMPTION: schema.extra will contain `minimalAmount` and `dstEid` for this scheme
    const minimalAmount = maxAmount -50; //schema.extra?.minimalAmount; // Keep as string for uint256
    const destinationChain = Number(scheme.extra?.dstEid); // Ensure numeric for uint16

    if (minimalAmount === undefined || isNaN(destinationChain)) {
        alert("Missing `minimalAmount` or invalid `dstEid` for payer0Plus_ scheme in PaymentRequirements.extra.");
        return;
    }

    const message = {
      from,
      to,
      amount: maxAmount.toString(), // maxAmountRequired from schema is the source chain amount
      minimalAmount: minimalAmount.toString(), // ensure it's stringified
      destinationChain: destinationChain.toString(),
      validAfter: validAfter.toString(),
      validBefore: validBefore.toString(),
      nonce
    };

    const domain = {
      name: tokenName,
      version: tokenVersion,
      chainId: expectedChainId,
      verifyingContract: tokenAddress
    };

    console.log("Payer0Plus Message (CrossChainTransferWithAuthorization):", message);
    console.log("Payer0Plus EIP-712 Domain:", domain);

    // To calculate the EIP-712 hash client-side, you would typically use a library
    // like ethers.js's _TypedDataEncoder:
    // import { _TypedDataEncoder } from '@ethersproject/hash'; // Or from ethers.utils
    // const hash = _TypedDataEncoder.hash(domain, types.CrossChainTransferWithAuthorization, message);
    // console.log("Payer0Plus EIP-712 Hash:", hash);
    // For this demo, the hash is implicitly calculated by MetaMask during signing.

    const signature = await signCrossChainTransferAuthorization(
      message,
      tokenAddress,
      tokenName,
      tokenVersion,
      expectedChainId
    );

    console.log("Signature:", signature);

    xPaymentHeader = {
      x402Version: 1,
      scheme: scheme.scheme,
      network: scheme.network,
      payload: {
        signature,
        authorization: message, // The full CrossChainTransferWithAuthorization message
        domain // The EIP-712 domain used for signing
      }
    };

  } ///----------------
   else if (scheme.scheme.startsWith("exact") || scheme.scheme.startsWith("payer0")) {
    const message = { from, to, value: maxAmount, validAfter, validBefore, nonce };
    const signature = await signTransferAuthorization(message, tokenAddress, tokenName, tokenVersion, expectedChainId); // Use expectedChainId

    const exactPayload = {
      signature,
      authorization: {
        from,
        to,
        value: maxAmount.toString(),
        validAfter: validAfter.toString(),
        validBefore: validBefore.toString(),
        nonce
      }
    };

    if (scheme.scheme.startsWith("payer0")) {
      const dstEid = Number(scheme.extra?.dstEid); // Ensure numeric
      // ASSUMPTION: schema.extra.minimalAmount exists for payer0 schemes
      const minimalAmount = scheme.extra?.minimalAmount ? scheme.extra.minimalAmount.toString() : "0";

      if (isNaN(dstEid)) {
        alert("Missing or invalid dstEid for payer0 scheme.");
        return;
      }
      console.log("dstEid for payer0:", dstEid);

      xPaymentHeader = {
        x402Version: 1,
        scheme: scheme.scheme,
        network: scheme.network,
        payload: {
          ...exactPayload,
          dstEid,
          minAmount: Number(minimalAmount) // Convert to Number if server expects
        }
      };
    } else { // exact scheme
      xPaymentHeader = {
        x402Version: 1,
        scheme: scheme.scheme,
        network: scheme.network,
        payload: exactPayload
      };
    }

  }  else {
    console.log("Unknown scheme:", scheme.scheme);
    alert(`Unknown payment scheme: ${scheme.scheme}`);
    return; // Prevent further execution for unknown schemes
  }

  try {
    const encodeHeader = document.getElementById('encodeCheckbox').checked;
    const headerValue = encodeHeader
      ? btoa(JSON.stringify(xPaymentHeader))
      : JSON.stringify(xPaymentHeader);

    const response = await fetch(currentHref, {
      method: 'GET',
      headers: {
        'X-Payment': headerValue
      }
    });

    if (response.ok) {
      const html = await response.text();
      document.open();
      document.write(html);
      document.close();
    } else {
      const errorData = await response.json();
      const errorMessage = `${errorData.error}\n\n${errorData.details}`;
      alert(`Access denied:\n\n${errorMessage}`);
    }

  } catch (error) {
    console.error("Error fetching resource with payment:", error);
  }

  closeModal();
}

    function closeModal() {
      document.getElementById('errorModal').style.display = 'none';
    }

    let currentSchemes = [];
    let currentHref = null;


    document.querySelectorAll('.resource-link').forEach(link => {
      link.addEventListener('click', async (event) => {
        event.preventDefault();
        const href = link.href;

        try {
          const res = await fetch(href);
          
          if (!res.ok && res.status === 402) {
            const data = await res.json();
            const accepts = data.accepts;

            const select = document.getElementById('paymentOptions');
            select.innerHTML = ''; // Clear existing options

            accepts.forEach((scheme, index) => {
              const token = scheme.extra?.name || 'Token';
              const amount = scheme.maxAmountRequired;
              const network = scheme.network;
              const option = document.createElement('option');
              option.value = index;
              option.text = `Pay ${amount / 1e6} ${token} on ${network} (${scheme.scheme})`;
              select.appendChild(option);
            });

            currentSchemes = accepts; // store all schemas
            currentHref = link.href;  // store href for later use

            document.getElementById('errorMessage').innerText = `Choose a payment method:`;
            document.getElementById('errorModal').style.display = 'block';
                  
          } else {
            window.location = href;
          }
        } catch (err) {
          console.error("Request failed:", err);
        }
      });
    });

    document.getElementById('connectButton').addEventListener('click', async () => {
      if (typeof window.ethereum !== 'undefined') {
        try {
          const accounts = await ethereum.request({ method: 'eth_requestAccounts' });
          const account = accounts[0];
          document.getElementById('walletAddress').innerText = `Connected: ${account}`;
        } catch (error) {
          console.error("User rejected the connection:", error);
        }
      } else {
        alert("MetaMask is not installed.");
      }
    });

    //----------------
  async function signTransferAuthorization(authorization, tokenAddress, tokenName = "USDC", tokenVersion = "2", chainId) {
  const { from, to, value, validAfter, validBefore, nonce } = authorization;

  console.log("Signature request", authorization, tokenAddress, tokenName, tokenVersion, chainId);

  const domain = {
    name: tokenName,
    version: tokenVersion,
    chainId,
    verifyingContract: tokenAddress
  };

  const types = {
    TransferWithAuthorization: [
      { name: 'from', type: 'address' },
      { name: 'to', type: 'address' },
      { name: 'value', type: 'uint256' },
      { name: 'validAfter', type: 'uint256' },
      { name: 'validBefore', type: 'uint256' },
      { name: 'nonce', type: 'bytes32' }
    ]
  };

  const message = {
    from,
    to,
    value,
    validAfter,
    validBefore,
    nonce
  };

  const typesJson = JSON.stringify({
    types: {
      EIP712Domain: [
        { name: "name", type: "string" },
        { name: "version", type: "string" },
        { name: "chainId", type: "uint256" },
        { name: "verifyingContract", type: "address" }
      ],
      ...types
    },
    domain,
    primaryType: "TransferWithAuthorization",
    message
  });

  const signature = await ethereum.request({
    method: 'eth_signTypedData_v4',
    params: [from, typesJson]
  });

  return signature;
}

async function checkWalletConnection() {
  if (typeof window.ethereum !== 'undefined') {
    try {
      const accounts = await ethereum.request({ method: 'eth_accounts' });
      if (accounts.length > 0) {
        const account = accounts[0];
        document.getElementById('walletAddress').innerText = `Connected: ${account}`;
        return true;
      } else {
        document.getElementById('walletAddress').innerText = 'Wallet not connected';
        return false;
      }
    } catch (error) {
      console.error("Error checking wallet accounts:", error);
      return false;
    }
  } else {
    document.getElementById('walletAddress').innerText = "MetaMask not installed";
    return false;
  }
}

// Call this on page load
window.addEventListener('load', () => {
  checkWalletConnection();
});


async function signPermitAuthorization(authorization, tokenAddress, tokenName = "MyToken", tokenVersion = "1", chainId) {
  const { owner, spender, value, nonce, deadline } = authorization;

  console.log("Permit signature request", authorization, tokenAddress, tokenName, tokenVersion, chainId);

  const domain = {
    name: tokenName,
    version: tokenVersion,
    chainId,
    verifyingContract: tokenAddress
  };

  const types = {
    Permit: [
      { name: "owner", type: "address" },
      { name: "spender", type: "address" },
      { name: "value", type: "uint256" },
      { name: "nonce", type: "uint256" },
      { name: "deadline", type: "uint256" }
    ]
  };

  const message = {
    owner,
    spender,
    value,
    nonce,
    deadline
  };

  const typesJson = JSON.stringify({
    types: {
      EIP712Domain: [
        { name: "name", type: "string" },
        { name: "version", type: "string" },
        { name: "chainId", type: "uint256" },
        { name: "verifyingContract", type: "address" }
      ],
      ...types
    },
    domain,
    primaryType: "Permit",
    message
  });

  const signature = await ethereum.request({
    method: 'eth_signTypedData_v4',
    params: [owner, typesJson]
  });

  return signature;
}

async function fetchPermitNonce(network, asset, owner) {
  try {
    const url = new URL('permitnonce', window.location.origin + window.location.pathname);

    url.searchParams.set('network', network);
    url.searchParams.set('asset', asset);
    url.searchParams.set('owner', owner);

    const response = await fetch(url.toString());

    if (!response.ok) {
      const errorData = await response.json();
      console.error('Failed to fetch permit nonce:', errorData.error || response.statusText);
      return null;
    }

    const data = await response.json();
    console.log('Permit nonce:', data.nonce);
    return data.nonce;
  } catch (err) {
    console.error('Error fetching permit nonce:', err);
    return null;
  }
}


//his assumes authorization.nonce is a 0x... 32-byte hex string.
//amount, minimalAmount, and other big numbers should be passed as stringified BigNumber
async function signCrossChainTransferAuthorization(authorization, tokenAddress, tokenName = "MyToken", tokenVersion = "1", chainId) {
  const {
    from,
    to,
    amount,
    minimalAmount,
    destinationChain,
    validAfter,
    validBefore,
    nonce
  } = authorization;

  console.log("Signature request", authorization, tokenAddress, tokenName, tokenVersion, chainId);

  const domain = {
    name: tokenName,
    version: tokenVersion,
    chainId,
    verifyingContract: tokenAddress
  };

  const types = {
    CrossChainTransferWithAuthorization: [
      { name: "from", type: "address" },
      { name: "to", type: "address" },
      { name: "amount", type: "uint256" },
      { name: "minimalAmount", type: "uint256" },
      { name: "destinationChain", type: "uint256" },  // encoded as uint256 per EIP-712 rules
      { name: "validAfter", type: "uint256" },
      { name: "validBefore", type: "uint256" },
      { name: "nonce", type: "bytes32" }
    ]
  };

  const message = {
    from,
    to,
    amount,
    minimalAmount,
    destinationChain,
    validAfter,
    validBefore,
    nonce
  };

  const typesJson = JSON.stringify({
    types: {
      EIP712Domain: [
        { name: "name", type: "string" },
        { name: "version", type: "string" },
        { name: "chainId", type: "uint256" },
        { name: "verifyingContract", type: "address" }
      ],
      ...types
    },
    domain,
    primaryType: "CrossChainTransferWithAuthorization",
    message
  });

  const signature = await ethereum.request({
    method: "eth_signTypedData_v4",
    params: [from, typesJson]
  });

  return signature;
}


async function PreparePermitHeader(data) {
  const nonce = await fetchPermitNonce(data.network, data.tokenAddress, data.from);
    const deadline = data.validBefore;

    const domain = {
      name: data.tokenName,
      version: data.tokenVersion,
      chainId: data.chainId,
      verifyingContract: data.tokenAddress
    };

    const message = {
      owner: data.from,
      spender: data.extra.facilitator,
      value: Number(data.maxAmount),
      deadline
    };

    const signature = await signPermitAuthorization({
      owner: data.from,
      spender: data.extra.facilitator,
      value: data.maxAmount,
      nonce,
      deadline
    }, data.tokenAddress, data.tokenName, data.tokenVersion, data.chainId);

    const xPaymentHeader =  {
    x402Version: 1,
    scheme: data.scheme.scheme,
    network: data.network,
    payload: {
      domain,
      message,
      nonce: Number(nonce),
      signature
    }
  };

    console.log("X-Payment Header (Permit):", JSON.stringify(xPaymentHeader));
    return xPaymentHeader;
}





  </script>
</body>
</html>
